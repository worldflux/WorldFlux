"""Scaffold template asset. Generated from sample-dreamer."""

DASHBOARD_INDEX_HTML = '<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1">\n    <title>WorldFlux Live Dashboard</title>\n    <link rel="preconnect" href="https://fonts.googleapis.com">\n    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>\n    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Manrope:wght@400;600;700&display=swap" rel="stylesheet">\n    <style>\n      :root {\n        --bg: #0d1012;\n        --surface: #14191d;\n        --surface-soft: #171d21;\n        --border: rgba(218, 228, 236, 0.14);\n        --border-strong: rgba(218, 228, 236, 0.28);\n        --text: #eff3f5;\n        --muted: #98a7b0;\n        --ok: #57c58f;\n        --warn: #d2b571;\n        --bad: #e07d7d;\n        --grid: rgba(177, 193, 203, 0.2);\n      }\n\n      * {\n        box-sizing: border-box;\n      }\n\n      body {\n        margin: 0;\n        color: var(--text);\n        font-family: "Manrope", "Segoe UI", sans-serif;\n        background: radial-gradient(circle at top, #121a1f 0%, #0d1012 48%, #0a0c0f 100%);\n      }\n\n      .container {\n        width: min(1140px, 94vw);\n        margin: 18px auto 28px;\n      }\n\n      .header {\n        border: 1px solid var(--border);\n        border-radius: 14px;\n        padding: 16px;\n        background: rgba(20, 25, 29, 0.95);\n        backdrop-filter: blur(8px);\n      }\n\n      .title {\n        margin: 0;\n        font-family: "Space Grotesk", sans-serif;\n        font-size: clamp(30px, 4vw, 42px);\n        font-weight: 700;\n        letter-spacing: 0.01em;\n      }\n\n      .subtitle {\n        margin: 6px 0 0;\n        color: var(--muted);\n        font-size: 13px;\n      }\n\n      .hint {\n        margin: 7px 0 0;\n        color: var(--muted);\n        font-size: 12px;\n      }\n\n      .cards {\n        margin-top: 12px;\n        display: grid;\n        grid-template-columns: repeat(auto-fit, minmax(165px, 1fr));\n        gap: 8px;\n      }\n\n      .card {\n        border: 1px solid var(--border);\n        border-radius: 11px;\n        background: var(--surface-soft);\n        padding: 10px 12px;\n      }\n\n      .label {\n        color: var(--muted);\n        font-size: 11px;\n        text-transform: uppercase;\n        letter-spacing: 0.08em;\n      }\n\n      .value {\n        margin-top: 6px;\n        font-size: 24px;\n        font-weight: 700;\n        line-height: 1;\n        font-family: "Space Grotesk", sans-serif;\n      }\n\n      .section {\n        margin-top: 12px;\n        border: 1px solid var(--border);\n        border-radius: 12px;\n        padding: 12px;\n        background: var(--surface);\n      }\n\n      .section h2 {\n        margin: 0 0 10px;\n        font-size: 13px;\n        font-weight: 600;\n        text-transform: uppercase;\n        letter-spacing: 0.08em;\n        color: var(--muted);\n      }\n\n      .gameplay-shell {\n        border: 1px solid var(--border);\n        border-radius: 10px;\n        overflow: hidden;\n        background: #080b0d;\n      }\n\n      #gameplay-canvas {\n        width: 100%;\n        height: min(48vw, 420px);\n        display: block;\n        background: #070a0d;\n      }\n\n      .gameplay-info {\n        border-top: 1px solid var(--border);\n        margin: 0;\n        padding: 8px 10px;\n        color: var(--muted);\n        font-size: 12px;\n      }\n\n      canvas.metrics {\n        width: 100%;\n        height: 250px;\n        border-radius: 10px;\n        border: 1px solid var(--border);\n        background: #101418;\n      }\n\n      #other-chart {\n        height: 300px;\n      }\n\n      .legend {\n        margin-top: 9px;\n        display: flex;\n        flex-wrap: wrap;\n        gap: 7px;\n      }\n\n      .legend-item {\n        display: inline-flex;\n        align-items: center;\n        gap: 6px;\n        border: 1px solid var(--border);\n        border-radius: 999px;\n        background: rgba(17, 22, 27, 0.9);\n        padding: 5px 9px;\n        color: var(--muted);\n        font-size: 12px;\n      }\n\n      .legend-item:hover {\n        border-color: var(--border-strong);\n      }\n\n      .dot {\n        width: 10px;\n        height: 10px;\n        border-radius: 50%;\n      }\n\n      @media (max-width: 860px) {\n        .container {\n          width: 96vw;\n          margin-top: 12px;\n        }\n\n        .value {\n          font-size: 22px;\n        }\n\n        #gameplay-canvas {\n          height: min(62vw, 320px);\n        }\n\n        canvas.metrics {\n          height: 220px;\n        }\n\n        #other-chart {\n          height: 250px;\n        }\n      }\n    </style>\n  </head>\n  <body>\n    <main class="container">\n      <header class="header">\n        <h1 class="title">WorldFlux Training Dashboard</h1>\n        <p class="subtitle">Live gameplay (Atari) + real-time training metrics</p>\n        <p class="hint">Hover cards or legend tags to see beginner-friendly metric explanations.</p>\n      </header>\n\n      <section class="cards">\n        <div class="card" data-metric="status">\n          <div class="label">Status</div>\n          <div id="status" class="value">starting</div>\n        </div>\n        <div class="card" data-metric="phase">\n          <div class="label">Phase</div>\n          <div id="phase" class="value">starting</div>\n        </div>\n        <div class="card" data-metric="step">\n          <div class="label">Step</div>\n          <div id="step" class="value">0</div>\n        </div>\n        <div class="card" data-metric="elapsed">\n          <div class="label">Elapsed</div>\n          <div id="elapsed" class="value">0s</div>\n        </div>\n        <div class="card" data-metric="speed">\n          <div class="label">Speed (step/s)</div>\n          <div id="speed" class="value">0.00</div>\n        </div>\n        <div class="card" data-metric="loss">\n          <div class="label">Loss</div>\n          <div id="loss" class="value">-</div>\n        </div>\n      </section>\n\n      <section class="section">\n        <h2>Live Gameplay</h2>\n        <div class="gameplay-shell">\n          <canvas id="gameplay-canvas"></canvas>\n          <p id="gameplay-info" class="gameplay-info">Waiting for gameplay stream...</p>\n        </div>\n      </section>\n\n      <section class="section">\n        <h2>Loss (Primary)</h2>\n        <canvas id="loss-chart" class="metrics"></canvas>\n      </section>\n\n      <section class="section">\n        <h2>Other Metrics + Speed</h2>\n        <canvas id="other-chart" class="metrics"></canvas>\n        <div id="legend" class="legend"></div>\n      </section>\n    </main>\n\n    <script>\n      const palette = [\n        "#53c997", "#65b1ff", "#f0c96a", "#ec7e86", "#c79cff",\n        "#78d4d4", "#ffad75", "#86d8af", "#ccd374", "#f6949e",\n      ];\n      const metricDescriptions = {\n        status:\n          "Overall training state. running means training is active, finished means done, error means it stopped unexpectedly.",\n        phase:\n          "Current pipeline stage. collecting = gathering environment data, training = optimization step, unavailable = gameplay stream is not active.",\n        step:\n          "How many optimizer updates have run. It usually increases by one each training iteration.",\n        elapsed:\n          "Real wall-clock time since this run started.",\n        speed:\n          "Training throughput in steps per second. Higher is faster execution.",\n        loss:\n          "Main training objective. Lower usually means the model is fitting data better.",\n        kl:\n          "Kullback-Leibler regularization. It keeps latent dynamics stable and prevents drift.",\n        reconstruction:\n          "Reconstruction error for observations. Lower means decoded frames/states are closer to targets.",\n        reward:\n          "Reward prediction error. Lower means predicted rewards match collected rewards better.",\n        continue:\n          "Continuation/terminal prediction error. Lower means better episode-end prediction.",\n      };\n\n      const state = {\n        status: "starting",\n        phase: "starting",\n        lastStep: -1,\n        points: [],\n        metricKeys: new Set(),\n        summary: null,\n        refreshMs: 1000,\n        summaryCounter: 0,\n        legendNodes: new Map(),\n        gameplay: {\n          status: "starting",\n          phase: "starting",\n          detail: "",\n          fps: 8,\n          lastSeq: -1,\n          queue: [],\n          current: null,\n          lastFrameTs: 0,\n          lastLiveFrameTs: 0,\n          offscreen: document.createElement("canvas"),\n        },\n      };\n\n      const statusEl = document.getElementById("status");\n      const phaseEl = document.getElementById("phase");\n      const stepEl = document.getElementById("step");\n      const elapsedEl = document.getElementById("elapsed");\n      const speedEl = document.getElementById("speed");\n      const lossEl = document.getElementById("loss");\n      const lossCanvas = document.getElementById("loss-chart");\n      const otherCanvas = document.getElementById("other-chart");\n      const legendEl = document.getElementById("legend");\n      const gameplayCanvas = document.getElementById("gameplay-canvas");\n      const gameplayInfoEl = document.getElementById("gameplay-info");\n      const metricCards = document.querySelectorAll(".card[data-metric]");\n\n      function metricDescription(metricName) {\n        return metricDescriptions[metricName] || "Training metric logged from this run.";\n      }\n\n      function initializeMetricTooltips() {\n        metricCards.forEach((card) => {\n          const metric = card.dataset.metric;\n          if (!metric) return;\n          const description = metricDescription(metric);\n          card.title = `${metric.toUpperCase()}: ${description}`;\n          card.setAttribute("aria-label", `${metric}: ${description}`);\n        });\n      }\n\n      function statusColor(status) {\n        if (status === "running") return "var(--ok)";\n        if (status === "finished") return "var(--warn)";\n        if (status === "error") return "var(--bad)";\n        return "var(--text)";\n      }\n\n      function formatNumber(value, digits = 4) {\n        if (typeof value !== "number" || Number.isNaN(value)) return "-";\n        return value.toFixed(digits);\n      }\n\n      function formatElapsed(totalSec) {\n        const sec = Math.max(0, Math.floor(totalSec || 0));\n        const h = Math.floor(sec / 3600);\n        const m = Math.floor((sec % 3600) / 60);\n        const s = sec % 60;\n        if (h > 0) return `${h}h ${m}m ${s}s`;\n        if (m > 0) return `${m}m ${s}s`;\n        return `${s}s`;\n      }\n\n      function pickColor(index) {\n        return palette[index % palette.length];\n      }\n\n      function clearCanvas(canvas) {\n        const dpr = window.devicePixelRatio || 1;\n        const rect = canvas.getBoundingClientRect();\n        const width = Math.max(1, Math.floor(rect.width * dpr));\n        const height = Math.max(1, Math.floor(rect.height * dpr));\n        if (canvas.width !== width || canvas.height !== height) {\n          canvas.width = width;\n          canvas.height = height;\n        }\n        const ctx = canvas.getContext("2d");\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.scale(dpr, dpr);\n        ctx.clearRect(0, 0, rect.width, rect.height);\n        return { ctx, width: rect.width, height: rect.height };\n      }\n\n      function drawChart(canvas, datasets) {\n        const { ctx, width, height } = clearCanvas(canvas);\n        const left = 42;\n        const right = width - 16;\n        const top = 14;\n        const bottom = height - 26;\n        const chartW = Math.max(1, right - left);\n        const chartH = Math.max(1, bottom - top);\n\n        const values = [];\n        for (const ds of datasets) {\n          for (const v of ds.values) {\n            if (typeof v === "number" && Number.isFinite(v)) {\n              values.push(v);\n            }\n          }\n        }\n\n        if (values.length === 0) {\n          ctx.fillStyle = "#95a7b1";\n          ctx.font = "13px Space Grotesk, sans-serif";\n          ctx.fillText("Waiting for data...", left, top + 20);\n          return;\n        }\n\n        let yMin = Math.min(...values);\n        let yMax = Math.max(...values);\n        if (yMin === yMax) {\n          yMin -= 1;\n          yMax += 1;\n        }\n        const pad = (yMax - yMin) * 0.08;\n        yMin -= pad;\n        yMax += pad;\n\n        ctx.strokeStyle = "var(--grid)";\n        ctx.lineWidth = 1;\n        for (let i = 0; i <= 4; i += 1) {\n          const y = top + (chartH * i) / 4;\n          ctx.beginPath();\n          ctx.moveTo(left, y);\n          ctx.lineTo(right, y);\n          ctx.stroke();\n        }\n\n        ctx.fillStyle = "#95a7b1";\n        ctx.font = "11px Space Grotesk, sans-serif";\n        ctx.fillText(yMax.toFixed(3), 2, top + 8);\n        ctx.fillText(yMin.toFixed(3), 2, bottom);\n\n        const n = state.points.length;\n        const xAt = (idx) => left + (chartW * idx) / Math.max(1, n - 1);\n        const yAt = (v) => top + ((yMax - v) / (yMax - yMin)) * chartH;\n\n        datasets.forEach((ds) => {\n          ctx.strokeStyle = ds.color;\n          ctx.lineWidth = ds.width || 1.7;\n          ctx.beginPath();\n          let started = false;\n\n          ds.values.forEach((v, idx) => {\n            if (typeof v !== "number" || !Number.isFinite(v)) {\n              started = false;\n              return;\n            }\n            const x = xAt(idx);\n            const y = yAt(v);\n            if (!started) {\n              ctx.moveTo(x, y);\n              started = true;\n            } else {\n              ctx.lineTo(x, y);\n            }\n          });\n\n          ctx.stroke();\n        });\n      }\n\n      function ensureLegendItem(label, color) {\n        let item = state.legendNodes.get(label);\n        if (!item) {\n          item = document.createElement("span");\n          item.className = "legend-item";\n\n          const dot = document.createElement("span");\n          dot.className = "dot";\n          item.appendChild(dot);\n\n          const text = document.createElement("span");\n          text.className = "legend-label";\n          item.appendChild(text);\n\n          state.legendNodes.set(label, item);\n        }\n\n        const dotEl = item.querySelector(".dot");\n        const labelEl = item.querySelector(".legend-label");\n        if (dotEl) {\n          dotEl.style.backgroundColor = color;\n        }\n        if (labelEl) {\n          labelEl.textContent = label;\n        }\n\n        const description = metricDescription(label);\n        item.title = `${label}: ${description}`;\n        item.setAttribute("aria-label", `${label}: ${description}`);\n        return item;\n      }\n\n      function updateLegend(datasets) {\n        const active = new Set();\n        datasets.forEach((ds) => {\n          const node = ensureLegendItem(ds.label, ds.color);\n          legendEl.appendChild(node);\n          active.add(ds.label);\n        });\n\n        for (const [label, node] of state.legendNodes.entries()) {\n          if (!active.has(label)) {\n            node.remove();\n            state.legendNodes.delete(label);\n          }\n        }\n      }\n\n      function latestPoint() {\n        return state.points.length > 0 ? state.points[state.points.length - 1] : null;\n      }\n\n      function renderMetrics() {\n        const latest = latestPoint();\n        statusEl.textContent = state.status;\n        statusEl.style.color = statusColor(state.status);\n\n        phaseEl.textContent = state.phase || "starting";\n        stepEl.textContent = latest ? String(latest.step) : "0";\n        speedEl.textContent = latest ? formatNumber(latest.speed, 2) : "0.00";\n        lossEl.textContent =\n          latest && typeof latest.metrics.loss === "number"\n            ? formatNumber(latest.metrics.loss, 5)\n            : "-";\n\n        const elapsed = state.summary ? state.summary.elapsed_seconds : 0;\n        elapsedEl.textContent = formatElapsed(elapsed);\n\n        drawChart(lossCanvas, [\n          {\n            label: "loss",\n            color: "#65b1ff",\n            width: 2.2,\n            values: state.points.map((p) => p.metrics.loss),\n          },\n        ]);\n\n        const otherKeys = Array.from(state.metricKeys).filter((k) => k !== "loss").sort();\n        const otherDatasets = otherKeys.map((key, idx) => ({\n          label: key,\n          color: pickColor(idx),\n          values: state.points.map((p) => p.metrics[key]),\n        }));\n\n        otherDatasets.push({\n          label: "speed",\n          color: pickColor(otherDatasets.length),\n          values: state.points.map((p) => p.speed),\n        });\n\n        drawChart(otherCanvas, otherDatasets);\n        updateLegend(otherDatasets);\n      }\n\n      function decodeFrame(frame) {\n        if (!frame || !frame.rgb_b64) return null;\n        const width = Number(frame.width || 0);\n        const height = Number(frame.height || 0);\n        if (!width || !height) return null;\n\n        try {\n          const binary = atob(frame.rgb_b64);\n          const expected = width * height * 3;\n          if (binary.length !== expected) return null;\n\n          const rgba = new Uint8ClampedArray(width * height * 4);\n          let rgbIdx = 0;\n          for (let i = 0; i < rgba.length; i += 4) {\n            rgba[i] = binary.charCodeAt(rgbIdx);\n            rgba[i + 1] = binary.charCodeAt(rgbIdx + 1);\n            rgba[i + 2] = binary.charCodeAt(rgbIdx + 2);\n            rgba[i + 3] = 255;\n            rgbIdx += 3;\n          }\n\n          return {\n            ...frame,\n            imageData: new ImageData(rgba, width, height),\n          };\n        } catch (err) {\n          console.error("failed to decode gameplay frame", err);\n          return null;\n        }\n      }\n\n      function drawGameplayFrame(frame) {\n        if (!frame || !frame.imageData) return;\n\n        const { ctx, width, height } = clearCanvas(gameplayCanvas);\n        const offscreen = state.gameplay.offscreen;\n        if (offscreen.width !== frame.width || offscreen.height !== frame.height) {\n          offscreen.width = frame.width;\n          offscreen.height = frame.height;\n        }\n        const offCtx = offscreen.getContext("2d");\n        offCtx.putImageData(frame.imageData, 0, 0);\n\n        const srcRatio = frame.width / frame.height;\n        const dstRatio = width / height;\n        let drawW = width;\n        let drawH = height;\n        let drawX = 0;\n        let drawY = 0;\n\n        if (srcRatio > dstRatio) {\n          drawH = width / srcRatio;\n          drawY = (height - drawH) / 2;\n        } else {\n          drawW = height * srcRatio;\n          drawX = (width - drawW) / 2;\n        }\n\n        ctx.fillStyle = "#070a0d";\n        ctx.fillRect(0, 0, width, height);\n        ctx.drawImage(offscreen, drawX, drawY, drawW, drawH);\n      }\n\n      function renderGameplayInfo() {\n        const current = state.gameplay.current;\n        const detail = state.gameplay.detail;\n\n        if (current) {\n          const staleSeconds =\n            state.gameplay.lastLiveFrameTs > 0\n              ? Math.max(0, (Date.now() - state.gameplay.lastLiveFrameTs) / 1000)\n              : 0;\n          const staleSuffix = staleSeconds >= 2 ? ` stale=${staleSeconds.toFixed(1)}s` : "";\n          gameplayInfoEl.textContent =\n            `status=${state.gameplay.status} phase=${state.gameplay.phase} ` +\n            `episode=${current.episode} step=${current.episode_step} reward=${formatNumber(current.reward, 3)}` +\n            staleSuffix;\n          return;\n        }\n\n        if (detail) {\n          gameplayInfoEl.textContent = detail;\n          return;\n        }\n\n        if (state.gameplay.phase === "unavailable") {\n          gameplayInfoEl.textContent = "Install gymnasium + ale-py to enable live gameplay.";\n          return;\n        }\n\n        gameplayInfoEl.textContent = "Waiting for gameplay stream...";\n      }\n\n      function gameplayLoop(timestamp) {\n        const fps = Math.max(1, Number(state.gameplay.fps) || 8);\n        const interval = 1000 / fps;\n\n        if (state.gameplay.queue.length > 0) {\n          if (state.gameplay.current === null || timestamp - state.gameplay.lastFrameTs >= interval) {\n            state.gameplay.current = state.gameplay.queue.shift();\n            state.gameplay.lastFrameTs = timestamp;\n          }\n        }\n\n        if (state.gameplay.current) {\n          drawGameplayFrame(state.gameplay.current);\n        }\n\n        renderGameplayInfo();\n        window.requestAnimationFrame(gameplayLoop);\n      }\n\n      async function fetchSummary() {\n        const res = await fetch("/api/summary", { cache: "no-store" });\n        if (!res.ok) return;\n\n        const payload = await res.json();\n        state.summary = payload;\n        state.status = payload.status || state.status;\n        state.phase = payload.phase || state.phase;\n\n        if (typeof payload.refresh_ms === "number" && payload.refresh_ms > 0) {\n          state.refreshMs = payload.refresh_ms;\n        }\n\n        if (typeof payload.gameplay_fps === "number" && payload.gameplay_fps > 0) {\n          state.gameplay.fps = payload.gameplay_fps;\n        }\n\n        if (payload.phase_message) {\n          state.gameplay.detail = String(payload.phase_message);\n        }\n      }\n\n      async function fetchMetrics() {\n        const res = await fetch(`/api/metrics?since_step=${state.lastStep}`, { cache: "no-store" });\n        if (!res.ok) return;\n\n        const payload = await res.json();\n        state.status = payload.status || state.status;\n        state.phase = payload.phase || state.phase;\n\n        if (Array.isArray(payload.points) && payload.points.length > 0) {\n          payload.points.forEach((point) => {\n            state.points.push(point);\n            state.lastStep = Math.max(state.lastStep, point.step);\n            if (point.metrics && typeof point.metrics === "object") {\n              Object.keys(point.metrics).forEach((key) => state.metricKeys.add(key));\n            }\n          });\n        }\n      }\n\n      async function fetchGameplay() {\n        const res = await fetch(`/api/gameplay?since_seq=${state.gameplay.lastSeq}`, {\n          cache: "no-store",\n        });\n        if (!res.ok) return;\n\n        const payload = await res.json();\n        state.gameplay.status = payload.status || state.gameplay.status;\n        state.gameplay.phase = payload.phase || state.gameplay.phase;\n        state.gameplay.detail = payload.detail || state.gameplay.detail;\n        if (typeof payload.fps === "number" && payload.fps > 0) {\n          state.gameplay.fps = payload.fps;\n        }\n\n        if (Array.isArray(payload.frames) && payload.frames.length > 0) {\n          payload.frames.forEach((frame) => {\n            const decoded = decodeFrame(frame);\n            if (!decoded) return;\n            state.gameplay.queue.push(decoded);\n            state.gameplay.lastSeq = Math.max(state.gameplay.lastSeq, decoded.seq);\n            state.gameplay.lastLiveFrameTs = Date.now();\n          });\n\n          while (state.gameplay.queue.length > 256) {\n            state.gameplay.queue.shift();\n          }\n        }\n      }\n\n      async function tick() {\n        try {\n          await fetchMetrics();\n          await fetchGameplay();\n          state.summaryCounter += 1;\n          if (state.summaryCounter % 5 === 0 || !state.summary) {\n            await fetchSummary();\n          }\n          renderMetrics();\n        } catch (err) {\n          console.error(err);\n        } finally {\n          setTimeout(tick, state.refreshMs);\n        }\n      }\n\n      window.addEventListener("resize", () => {\n        renderMetrics();\n        if (state.gameplay.current) {\n          drawGameplayFrame(state.gameplay.current);\n        }\n      });\n\n      initializeMetricTooltips();\n      tick();\n      window.requestAnimationFrame(gameplayLoop);\n    </script>\n  </body>\n</html>\n'
