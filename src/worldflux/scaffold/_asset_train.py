"""Scaffold template asset. Generated from sample-dreamer."""

TRAIN_PY = 'from __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import Any\n\nfrom dataset import build_training_data\nfrom local_dashboard import DashboardCallback, GameplayBuffer, MetricBuffer, MetricsDashboardServer\n\nfrom worldflux import create_world_model\nfrom worldflux.training import Trainer, TrainingConfig\n\ntry:\n    import tomllib  # Python 3.11+\nexcept ModuleNotFoundError:  # pragma: no cover\n    import tomli as tomllib\n\n\ndef load_config(path: str = "worldflux.toml") -> dict:\n    config_path = Path(path)\n    if not config_path.exists():\n        raise FileNotFoundError(f"Missing config file: {config_path}")\n    with config_path.open("rb") as f:\n        return tomllib.load(f)\n\n\ndef resolve_model_id(config: dict) -> str:\n    model = str(config.get("model", "")).strip()\n    if model:\n        return model\n    model_type = str(config.get("model_type", "dreamer")).strip().lower()\n    if model_type.startswith("dreamer"):\n        return "dreamer:ci"\n    return "tdmpc2:ci"\n\n\ndef resolve_visualization_config(config: dict[str, Any]) -> dict[str, Any]:\n    visual = config.get("visualization", {})\n    if not isinstance(visual, dict):\n        visual = {}\n\n    host = str(visual.get("host", "127.0.0.1")).strip() or "127.0.0.1"\n    port = int(visual.get("port", 8765))\n    refresh_ms = max(100, int(visual.get("refresh_ms", 1000)))\n    history_max_points = max(100, int(visual.get("history_max_points", 2000)))\n\n    return {\n        "enabled": bool(visual.get("enabled", True)),\n        "host": host,\n        "port": max(1, port),\n        "refresh_ms": refresh_ms,\n        "history_max_points": history_max_points,\n        "open_browser": bool(visual.get("open_browser", False)),\n    }\n\n\ndef resolve_gameplay_config(config: dict[str, Any]) -> dict[str, Any]:\n    gameplay = config.get("gameplay", {})\n    if not isinstance(gameplay, dict):\n        gameplay = {}\n\n    return {\n        "enabled": bool(gameplay.get("enabled", True)),\n        "fps": max(1, int(gameplay.get("fps", 8))),\n        "max_frames": max(16, int(gameplay.get("max_frames", 512))),\n    }\n\n\ndef main() -> None:\n    config = load_config()\n    architecture = config.get("architecture", {})\n    training = config.get("training", {})\n    visualization = resolve_visualization_config(config)\n    gameplay = resolve_gameplay_config(config)\n\n    obs_shape = tuple(int(dim) for dim in architecture.get("obs_shape", [3, 64, 64]))\n    action_dim = int(architecture.get("action_dim", 6))\n    hidden_dim = int(architecture.get("hidden_dim", 32))\n    model_id = resolve_model_id(config)\n    device = str(training.get("device", "cpu"))\n    total_steps = int(training.get("total_steps", 100000))\n    batch_size = int(training.get("batch_size", 16))\n    sequence_length = int(training.get("sequence_length", 50))\n    learning_rate = float(training.get("learning_rate", 3e-4))\n    output_dir = str(training.get("output_dir", "./outputs"))\n\n    print(f"Initializing model: {model_id} on {device}")\n    model = create_world_model(\n        model=model_id,\n        obs_shape=obs_shape,\n        action_dim=action_dim,\n        hidden_dim=hidden_dim,\n        device=device,\n    )\n\n    dashboard_buffer: MetricBuffer | None = None\n    gameplay_buffer: GameplayBuffer | None = None\n    dashboard_server: MetricsDashboardServer | None = None\n    dashboard_callback: DashboardCallback | None = None\n    extra_callbacks = []\n    gameplay_unavailable = not gameplay["enabled"]\n    unavailable_detail: str | None = (\n        "Gameplay stream disabled in worldflux.toml." if not gameplay["enabled"] else None\n    )\n\n    def publish_phase(phase: str, detail: str | None = None) -> None:\n        nonlocal gameplay_unavailable, unavailable_detail\n\n        if phase == "unavailable":\n            gameplay_unavailable = True\n            unavailable_detail = detail or unavailable_detail\n\n        if dashboard_buffer is not None:\n            dashboard_buffer.set_phase(phase, detail)\n            if phase == "unavailable":\n                dashboard_buffer.set_gameplay_available(False)\n\n        if gameplay_buffer is not None:\n            gameplay_buffer.set_phase(phase, detail)\n            if phase == "unavailable":\n                gameplay_buffer.set_status("unavailable")\n            elif phase in {"finished", "error"}:\n                gameplay_buffer.set_status(phase)\n            else:\n                gameplay_buffer.set_status("running")\n\n    def publish_frame(\n        frame: Any,\n        episode: int,\n        episode_step: int,\n        reward: float,\n        done: bool,\n    ) -> None:\n        if gameplay_buffer is None:\n            return\n        gameplay_buffer.append_frame(\n            frame,\n            episode=episode,\n            episode_step=episode_step,\n            reward=reward,\n            done=done,\n        )\n\n    if visualization["enabled"]:\n        try:\n            dashboard_buffer = MetricBuffer(max_points=visualization["history_max_points"])\n            if gameplay["enabled"]:\n                gameplay_buffer = GameplayBuffer(\n                    max_frames=int(gameplay["max_frames"]),\n                    fps=int(gameplay["fps"]),\n                )\n                dashboard_buffer.set_gameplay_available(True)\n            else:\n                dashboard_buffer.set_gameplay_available(False)\n                dashboard_buffer.set_phase("unavailable", unavailable_detail)\n\n            dashboard_server = MetricsDashboardServer(\n                metric_buffer=dashboard_buffer,\n                gameplay_buffer=gameplay_buffer,\n                host=str(visualization["host"]),\n                start_port=int(visualization["port"]),\n                dashboard_root=Path(__file__).parent / "dashboard",\n                refresh_ms=int(visualization["refresh_ms"]),\n                max_port_tries=100,\n            )\n            dashboard_server.start()\n            print(f"Dashboard: {dashboard_server.url}")\n\n            if visualization["open_browser"]:\n                dashboard_server.open_browser()\n\n            dashboard_callback = DashboardCallback(\n                dashboard_buffer,\n                Path(output_dir) / "metrics.jsonl",\n            )\n            extra_callbacks.append(dashboard_callback)\n        except Exception as exc:\n            dashboard_buffer = None\n            gameplay_buffer = None\n            dashboard_server = None\n            dashboard_callback = None\n            print(f"Visualization disabled (startup failed): {exc}")\n\n    print("Preparing training data...")\n    if dashboard_buffer is not None and gameplay["enabled"]:\n        publish_phase("collecting")\n\n    def _noop_cleanup() -> None:\n        return\n\n    cleanup_data_source = _noop_cleanup\n    data_mode = "offline"\n    data_source, cleanup_data_source, data_mode = build_training_data(\n        model.config,\n        frame_callback=publish_frame if gameplay["enabled"] else None,\n        phase_callback=publish_phase if dashboard_buffer is not None else None,\n    )\n\n    if dashboard_buffer is not None:\n        if gameplay_unavailable:\n            publish_phase("unavailable", unavailable_detail)\n        else:\n            publish_phase("training")\n\n    print(\n        "Training config: "\n        f"steps={total_steps}, batch_size={batch_size}, "\n        f"sequence_length={sequence_length}, lr={learning_rate}, mode={data_mode}"\n    )\n\n    trainer = Trainer(\n        model,\n        TrainingConfig(\n            total_steps=total_steps,\n            batch_size=batch_size,\n            sequence_length=sequence_length,\n            learning_rate=learning_rate,\n            output_dir=output_dir,\n            device=device,\n        ),\n        callbacks=extra_callbacks or None,\n    )\n\n    print("Starting training...")\n    failed_error: Exception | None = None\n    try:\n        trainer.train(data_source)\n    except Exception as exc:\n        failed_error = exc\n        if dashboard_buffer is not None:\n            dashboard_buffer.set_status("error", str(exc))\n            dashboard_buffer.set_phase("error", str(exc))\n            dashboard_buffer.set_gameplay_available(not gameplay_unavailable)\n        if gameplay_buffer is not None:\n            gameplay_buffer.set_status("error")\n            gameplay_buffer.set_phase("error", str(exc))\n        if dashboard_callback is not None:\n            dashboard_callback.close()\n        raise\n    finally:\n        try:\n            cleanup_data_source()\n        except Exception as exc:\n            print(f"Data source cleanup failed: {exc}")\n\n        if dashboard_server is not None:\n            linger_seconds = 60.0\n            if failed_error is None and dashboard_buffer is not None:\n                dashboard_buffer.set_status("finished")\n                dashboard_buffer.set_phase("finished")\n                dashboard_buffer.set_gameplay_available(not gameplay_unavailable)\n            if failed_error is None and gameplay_buffer is not None:\n                gameplay_buffer.set_status("finished")\n                gameplay_buffer.set_phase("finished")\n            dashboard_server.schedule_shutdown(linger_seconds)\n            print(\n                "Dashboard will stay online for " f"{int(linger_seconds)}s: {dashboard_server.url}"\n            )\n            dashboard_server.wait_for_stop(timeout=linger_seconds + 5.0)\n\n    print("Training complete.")\n\n\nif __name__ == "__main__":\n    main()\n'
