"""Scaffold template asset. Generated from sample-dreamer."""

LOCAL_DASHBOARD_PY = 'from __future__ import annotations\n\nimport base64\nimport json\nimport threading\nimport time\nimport webbrowser\nfrom collections import deque\nfrom http import HTTPStatus\nfrom http.server import BaseHTTPRequestHandler, ThreadingHTTPServer\nfrom pathlib import Path\nfrom typing import Any, TypedDict\nfrom urllib.parse import parse_qs, urlparse\n\nimport numpy as np\n\nfrom worldflux.training.callbacks import Callback\n\n\nclass MetricPoint(TypedDict):\n    step: int\n    timestamp: float\n    speed: float\n    metrics: dict[str, float]\n\n\nclass MetricBuffer:\n    """Thread-safe ring buffer for training metrics."""\n\n    def __init__(self, max_points: int = 2000):\n        self._points: deque[MetricPoint] = deque(maxlen=max(1, int(max_points)))\n        self._lock = threading.Lock()\n        self._status = "running"\n        self._phase = "starting"\n        self._phase_message: str | None = None\n        self._gameplay_available = False\n        self._error: str | None = None\n        self._started_at = time.time()\n        self._ended_at: float | None = None\n        self._latest_step = 0\n        self._latest_metrics: dict[str, float] = {}\n        self._latest_speed = 0.0\n\n    def append(\n        self,\n        *,\n        step: int,\n        timestamp: float,\n        speed: float,\n        metrics: dict[str, float],\n    ) -> MetricPoint:\n        point: MetricPoint = {\n            "step": int(step),\n            "timestamp": float(timestamp),\n            "speed": float(speed),\n            "metrics": {k: float(v) for k, v in metrics.items()},\n        }\n        with self._lock:\n            self._points.append(point)\n            self._latest_step = point["step"]\n            self._latest_metrics = dict(point["metrics"])\n            self._latest_speed = point["speed"]\n        return point\n\n    def set_status(self, status: str, error: str | None = None) -> None:\n        now = time.time()\n        normalized = status if status in {"running", "finished", "error"} else "error"\n        with self._lock:\n            self._status = normalized\n            if normalized == "error":\n                self._phase = "error"\n            if error:\n                self._error = str(error)\n            if normalized in {"finished", "error"}:\n                self._ended_at = now\n\n    def set_phase(self, phase: str, message: str | None = None) -> None:\n        with self._lock:\n            self._phase = phase\n            self._phase_message = message\n\n    def set_gameplay_available(self, available: bool) -> None:\n        with self._lock:\n            self._gameplay_available = bool(available)\n\n    def metrics_payload(self, since_step: int = -1) -> dict[str, Any]:\n        with self._lock:\n            points = [p for p in self._points if p["step"] > since_step]\n            payload_points = [\n                {\n                    "step": p["step"],\n                    "timestamp": p["timestamp"],\n                    "speed": p["speed"],\n                    "metrics": dict(p["metrics"]),\n                }\n                for p in points\n            ]\n            return {\n                "status": self._status,\n                "phase": self._phase,\n                "latest_step": self._latest_step,\n                "points": payload_points,\n            }\n\n    def summary_payload(self, *, host: str, port: int) -> dict[str, Any]:\n        with self._lock:\n            ended_at = self._ended_at\n            now = time.time()\n            return {\n                "status": self._status,\n                "phase": self._phase,\n                "phase_message": self._phase_message,\n                "gameplay_available": self._gameplay_available,\n                "started_at": self._started_at,\n                "ended_at": ended_at,\n                "elapsed_seconds": (ended_at or now) - self._started_at,\n                "latest_step": self._latest_step,\n                "latest_metrics": dict(self._latest_metrics),\n                "latest_speed": self._latest_speed,\n                "error": self._error,\n                "host": host,\n                "port": int(port),\n                "total_points": len(self._points),\n            }\n\n\nclass GameplayFrame(TypedDict):\n    seq: int\n    timestamp: float\n    width: int\n    height: int\n    rgb_b64: str\n    episode: int\n    episode_step: int\n    reward: float\n    done: bool\n\n\nclass GameplayBuffer:\n    """Thread-safe ring buffer for gameplay frames."""\n\n    def __init__(self, max_frames: int = 512, fps: int = 8):\n        self._frames: deque[GameplayFrame] = deque(maxlen=max(1, int(max_frames)))\n        self._fps = max(1, int(fps))\n        self._lock = threading.Lock()\n        self._latest_seq = 0\n        self._status = "running"\n        self._phase = "starting"\n        self._detail: str | None = None\n\n    @property\n    def fps(self) -> int:\n        return self._fps\n\n    def set_phase(self, phase: str, detail: str | None = None) -> None:\n        with self._lock:\n            self._phase = phase\n            self._detail = detail\n\n    def set_status(self, status: str) -> None:\n        normalized = (\n            status if status in {"running", "finished", "error", "unavailable"} else "error"\n        )\n        with self._lock:\n            self._status = normalized\n\n    def append_frame(\n        self,\n        frame: Any,\n        *,\n        episode: int,\n        episode_step: int,\n        reward: float,\n        done: bool,\n    ) -> None:\n        rgb = self._normalize_frame(frame)\n        if rgb is None:\n            return\n\n        now = time.time()\n        with self._lock:\n            self._latest_seq += 1\n            encoded = base64.b64encode(rgb.tobytes()).decode("ascii")\n            self._frames.append(\n                {\n                    "seq": self._latest_seq,\n                    "timestamp": now,\n                    "width": int(rgb.shape[1]),\n                    "height": int(rgb.shape[0]),\n                    "rgb_b64": encoded,\n                    "episode": int(episode),\n                    "episode_step": int(episode_step),\n                    "reward": float(reward),\n                    "done": bool(done),\n                }\n            )\n\n    def payload(self, since_seq: int = -1) -> dict[str, Any]:\n        with self._lock:\n            frames = [frame for frame in self._frames if frame["seq"] > since_seq]\n            return {\n                "status": self._status,\n                "phase": self._phase,\n                "detail": self._detail,\n                "latest_seq": self._latest_seq,\n                "fps": self._fps,\n                "frames": [dict(frame) for frame in frames],\n            }\n\n    @staticmethod\n    def _normalize_frame(frame: Any) -> np.ndarray | None:\n        arr = np.asarray(frame)\n        if arr.size == 0:\n            return None\n\n        if arr.ndim == 2:\n            arr = np.repeat(arr[:, :, None], 3, axis=2)\n        elif arr.ndim == 3:\n            if arr.shape[0] in (1, 3, 4) and arr.shape[-1] not in (1, 3, 4):\n                arr = np.transpose(arr, (1, 2, 0))\n            if arr.shape[-1] == 1:\n                arr = np.repeat(arr, 3, axis=2)\n            elif arr.shape[-1] >= 3:\n                arr = arr[:, :, :3]\n        else:\n            return None\n\n        if arr.ndim != 3 or arr.shape[-1] != 3:\n            return None\n\n        if np.issubdtype(arr.dtype, np.floating):\n            max_value = float(np.max(arr))\n            if max_value <= 1.0:\n                arr = arr * 255.0\n\n        return np.clip(arr, 0, 255).astype(np.uint8, copy=False)\n\n\nclass DashboardCallback(Callback):\n    """Trainer callback that streams metrics into a MetricBuffer and JSONL file."""\n\n    def __init__(self, buffer: MetricBuffer, jsonl_path: Path):\n        self.buffer = buffer\n        self.jsonl_path = jsonl_path\n        self._last_time: float | None = None\n        self._last_step: int | None = None\n        self._handle: Any = None\n\n    def on_train_begin(self, trainer) -> None:  # type: ignore[override]\n        del trainer\n        self.jsonl_path.parent.mkdir(parents=True, exist_ok=True)\n        self._handle = self.jsonl_path.open("a", encoding="utf-8", buffering=1)\n        self._last_time = None\n        self._last_step = None\n        self.buffer.set_status("running")\n\n    def on_step_end(self, trainer) -> None:  # type: ignore[override]\n        step = int(trainer.state.global_step)\n        now = time.time()\n        metrics = {k: float(v) for k, v in trainer.state.metrics.items()}\n\n        if self._last_time is None or self._last_step is None:\n            speed = 0.0\n        else:\n            dt = now - self._last_time\n            ds = step - self._last_step\n            speed = float(ds / dt) if dt > 0 and ds > 0 else 0.0\n\n        self._last_time = now\n        self._last_step = step\n\n        point = self.buffer.append(step=step, timestamp=now, speed=speed, metrics=metrics)\n        if self._handle is not None:\n            self._handle.write(json.dumps(point, separators=(",", ":")) + "\\n")\n\n    def on_train_end(self, trainer) -> None:  # type: ignore[override]\n        del trainer\n        self.buffer.set_status("finished")\n        self.close()\n\n    def close(self) -> None:\n        if self._handle is not None:\n            self._handle.close()\n            self._handle = None\n\n\nclass _DashboardHTTPServer(ThreadingHTTPServer):\n    def __init__(\n        self,\n        server_address: tuple[str, int],\n        request_handler_class,\n        *,\n        metric_buffer: MetricBuffer,\n        gameplay_buffer: GameplayBuffer | None,\n        dashboard_root: Path,\n        bind_host: str,\n        refresh_ms: int,\n    ):\n        super().__init__(server_address, request_handler_class)\n        self.metric_buffer = metric_buffer\n        self.gameplay_buffer = gameplay_buffer\n        self.dashboard_root = dashboard_root\n        self.bind_host = bind_host\n        self.refresh_ms = int(refresh_ms)\n\n\nclass _DashboardRequestHandler(BaseHTTPRequestHandler):\n    server: _DashboardHTTPServer\n\n    def do_GET(self) -> None:  # noqa: N802\n        parsed = urlparse(self.path)\n        path = parsed.path\n\n        if path in {"/", "/index.html"}:\n            self._serve_file(self.server.dashboard_root / "index.html", "text/html; charset=utf-8")\n            return\n\n        if path == "/api/metrics":\n            query = parse_qs(parsed.query)\n            raw = query.get("since_step", ["-1"])[0]\n            try:\n                since_step = int(raw)\n            except (TypeError, ValueError):\n                since_step = -1\n            self._send_json(self.server.metric_buffer.metrics_payload(since_step=since_step))\n            return\n\n        if path == "/api/summary":\n            payload = self.server.metric_buffer.summary_payload(\n                host=self.server.bind_host,\n                port=self.server.server_port,\n            )\n            if self.server.gameplay_buffer is not None:\n                payload["gameplay_fps"] = self.server.gameplay_buffer.fps\n            self._send_json(\n                {\n                    **payload,\n                    "refresh_ms": self.server.refresh_ms,\n                }\n            )\n            return\n\n        if path == "/api/gameplay":\n            query = parse_qs(parsed.query)\n            raw = query.get("since_seq", ["-1"])[0]\n            try:\n                since_seq = int(raw)\n            except (TypeError, ValueError):\n                since_seq = -1\n\n            if self.server.gameplay_buffer is None:\n                self._send_json(\n                    {\n                        "status": "unavailable",\n                        "phase": "unavailable",\n                        "detail": "Gameplay stream is disabled.",\n                        "latest_seq": 0,\n                        "fps": 0,\n                        "frames": [],\n                    }\n                )\n                return\n\n            self._send_json(self.server.gameplay_buffer.payload(since_seq=since_seq))\n            return\n\n        if path == "/healthz":\n            self._send_text("ok\\n", status=HTTPStatus.OK)\n            return\n\n        self._send_text("not found\\n", status=HTTPStatus.NOT_FOUND)\n\n    def _serve_file(self, path: Path, content_type: str) -> None:\n        if not path.exists() or not path.is_file():\n            self._send_text("not found\\n", status=HTTPStatus.NOT_FOUND)\n            return\n        data = path.read_bytes()\n        self.send_response(HTTPStatus.OK)\n        self.send_header("Content-Type", content_type)\n        self.send_header("Content-Length", str(len(data)))\n        self.end_headers()\n        self.wfile.write(data)\n\n    def _send_json(self, payload: dict[str, Any], status: HTTPStatus = HTTPStatus.OK) -> None:\n        data = json.dumps(payload, separators=(",", ":")).encode("utf-8")\n        self.send_response(status)\n        self.send_header("Content-Type", "application/json; charset=utf-8")\n        self.send_header("Cache-Control", "no-cache")\n        self.send_header("Content-Length", str(len(data)))\n        self.end_headers()\n        self.wfile.write(data)\n\n    def _send_text(self, text: str, status: HTTPStatus) -> None:\n        data = text.encode("utf-8")\n        self.send_response(status)\n        self.send_header("Content-Type", "text/plain; charset=utf-8")\n        self.send_header("Content-Length", str(len(data)))\n        self.end_headers()\n        self.wfile.write(data)\n\n    def log_message(self, format: str, *args: Any) -> None:  # noqa: A003\n        del format, args\n\n\nclass MetricsDashboardServer:\n    """Small local HTTP server for visualizing training metrics."""\n\n    def __init__(\n        self,\n        *,\n        metric_buffer: MetricBuffer,\n        gameplay_buffer: GameplayBuffer | None = None,\n        host: str,\n        start_port: int,\n        dashboard_root: Path,\n        refresh_ms: int,\n        max_port_tries: int = 100,\n    ):\n        self.metric_buffer = metric_buffer\n        self.gameplay_buffer = gameplay_buffer\n        self.host = host\n        self.start_port = int(start_port)\n        self.dashboard_root = dashboard_root\n        self.refresh_ms = max(100, int(refresh_ms))\n        self.max_port_tries = max(1, int(max_port_tries))\n\n        self._server: _DashboardHTTPServer | None = None\n        self._thread: threading.Thread | None = None\n        self._stopped_event = threading.Event()\n\n    @property\n    def port(self) -> int:\n        if self._server is None:\n            raise RuntimeError("dashboard server is not started")\n        return int(self._server.server_port)\n\n    @property\n    def url(self) -> str:\n        return f"http://{self.host}:{self.port}"\n\n    def start(self) -> int:\n        if self._server is not None:\n            return self.port\n\n        index_path = self.dashboard_root / "index.html"\n        if not index_path.exists():\n            raise RuntimeError(f"dashboard file not found: {index_path}")\n\n        last_error: Exception | None = None\n        for offset in range(self.max_port_tries):\n            candidate = self.start_port + offset\n            try:\n                self._server = _DashboardHTTPServer(\n                    (self.host, candidate),\n                    _DashboardRequestHandler,\n                    metric_buffer=self.metric_buffer,\n                    gameplay_buffer=self.gameplay_buffer,\n                    dashboard_root=self.dashboard_root,\n                    bind_host=self.host,\n                    refresh_ms=self.refresh_ms,\n                )\n                break\n            except OSError as exc:\n                last_error = exc\n\n        if self._server is None:\n            raise RuntimeError(\n                f"failed to bind dashboard port after {self.max_port_tries} attempts"\n            ) from last_error\n\n        self._stopped_event.clear()\n        self._thread = threading.Thread(target=self._serve, name="metrics-dashboard", daemon=False)\n        self._thread.start()\n        return self.port\n\n    def _serve(self) -> None:\n        assert self._server is not None\n        try:\n            self._server.serve_forever(poll_interval=0.5)\n        finally:\n            self._stopped_event.set()\n\n    def open_browser(self) -> None:\n        webbrowser.open(self.url)\n\n    def stop(self) -> None:\n        server = self._server\n        if server is None:\n            self._stopped_event.set()\n            return\n        server.shutdown()\n        server.server_close()\n        self._server = None\n        self._stopped_event.set()\n\n    def schedule_shutdown(self, delay_seconds: float) -> None:\n        def _shutdown_later() -> None:\n            time.sleep(max(0.0, float(delay_seconds)))\n            self.stop()\n\n        thread = threading.Thread(\n            target=_shutdown_later, name="metrics-dashboard-shutdown", daemon=True\n        )\n        thread.start()\n\n    def wait_for_stop(self, timeout: float | None = None) -> bool:\n        return self._stopped_event.wait(timeout=timeout)\n'
