{
  "function_signatures": {
    "create_world_model": "(model: str, *, obs_shape: tuple[int, ...] | None = None, action_dim: int | None = None, observation_modalities: dict[str, dict[str, typing.Any]] | None = None, action_spec: dict[str, typing.Any] | None = None, component_overrides: dict[str, object] | None = None, device: str = 'cpu', api_version: str = 'v3', **kwargs: Any) -> worldflux.core.model.WorldModel",
    "get_config": "(model: str, *, obs_shape: tuple[int, ...] | None = None, action_dim: int | None = None, **kwargs: Any) -> worldflux.core.config.WorldModelConfig",
    "get_model_info": "(model: str) -> dict[str, typing.Any]",
    "list_models": "(verbose: bool = False, maturity: str | None = None) -> list[str] | dict[str, dict[str, typing.Any]]"
  },
  "worldflux_all": [
    "ACTION_COMPONENTS_KEY",
    "ActionConditioner",
    "ActionPayload",
    "ActionSequence",
    "ActionSpec",
    "AsyncDecoder",
    "AsyncDynamicsModel",
    "AsyncObservationEncoder",
    "AsyncRolloutExecutor",
    "AutoConfig",
    "AutoWorldModel",
    "Batch",
    "BatchProvider",
    "BatchProviderV2",
    "BatchRequest",
    "Capability",
    "CategoricalLatentSpace",
    "ComponentSpec",
    "ConditionPayload",
    "ConditionSpec",
    "Decoder",
    "DiTSkeletonConfig",
    "DiTSkeletonWorldModel",
    "DiffusionWorldModel",
    "DiffusionWorldModelConfig",
    "DreamerV3Config",
    "DreamerV3WorldModel",
    "DynamicsModel",
    "DynamicsType",
    "GANSkeletonConfig",
    "GANSkeletonWorldModel",
    "GaussianLatentSpace",
    "JEPABaseConfig",
    "JEPABaseWorldModel",
    "LatentSpace",
    "LatentType",
    "LossOutput",
    "MODEL_ALIASES",
    "MODEL_CATALOG",
    "ModalityKind",
    "ModalitySpec",
    "ModelIOContract",
    "ModelMaturity",
    "ModelOutput",
    "ObservationSpec",
    "PLANNER_HORIZON_KEY",
    "PLANNER_SEQUENCE_KEY",
    "PhysicsSkeletonConfig",
    "PhysicsSkeletonWorldModel",
    "Planner",
    "PlannerObjective",
    "PluginManifest",
    "PredictionSpec",
    "Renderer3DSkeletonConfig",
    "Renderer3DSkeletonWorldModel",
    "RewardObjective",
    "RolloutEngine",
    "RolloutExecutor",
    "SSMSkeletonConfig",
    "SSMSkeletonWorldModel",
    "SequenceFieldSpec",
    "SequenceLayout",
    "SequenceProvider",
    "SimNormLatentSpace",
    "State",
    "StateSpec",
    "TDMPC2Config",
    "TDMPC2WorldModel",
    "TokenProvider",
    "TokenSpec",
    "TokenWorldModel",
    "TokenWorldModelConfig",
    "Trajectory",
    "TransitionProvider",
    "VJEPA2Config",
    "VJEPA2WorldModel",
    "VideoProvider",
    "WorldModel",
    "WorldModelConfig",
    "WorldModelInput",
    "WorldModelOutput",
    "WorldModelRegistry",
    "create_world_model",
    "first_action",
    "get_config",
    "get_model_info",
    "is_namespaced_extra_key",
    "list_models",
    "normalize_planned_action",
    "set_seed"
  ],
  "worldmodel_signatures": {
    "decode": "(self, state: 'State', conditions: 'ConditionPayload | None' = None) -> 'ModelOutput'",
    "encode": "(self, obs: 'Tensor | dict[str, Tensor] | WorldModelInput', deterministic: 'bool' = False) -> 'State'",
    "from_pretrained": "(name_or_path: 'str', **kwargs: 'Any') -> 'WorldModel'",
    "io_contract": "(self) -> 'ModelIOContract'",
    "loss": "(self, batch: 'Batch') -> 'LossOutput'",
    "rollout": "(self, initial_state: 'State', action_sequence: 'ActionSequence | ActionPayload | Tensor | None', conditions: 'ConditionPayload | None' = None, deterministic: 'bool' = False, mode: 'str' = 'autoregressive') -> 'Trajectory'",
    "save_pretrained": "(self, path: 'str') -> 'None'",
    "transition": "(self, state: 'State', action: 'ActionPayload | Tensor | None', conditions: 'ConditionPayload | None' = None, deterministic: 'bool' = False) -> 'State'",
    "update": "(self, state: 'State', action: 'ActionPayload | Tensor | None', obs: 'Tensor | dict[str, Tensor] | WorldModelInput', conditions: 'ConditionPayload | None' = None) -> 'State'"
  }
}
